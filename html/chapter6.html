<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第 6 章 Agent Handoff：任务移交与协作协议</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">基于多模态理解生成模型的智能体构建教程（目录）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 1 章 多模态智能体概览 (Chapter 1: Overview of Multimodal Agents)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 2 章 多模态输入输出与上下文管理 (Multimodal I/O & Context)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[第 3 章 Tool Call：工具调用设计与编排](https://www.google.com/search?q=chapter3.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 4 章 Agent Loop：规划-执行-反思的闭环</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 5 章 记忆与知识：RAG、多模态检索与状态管理</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 6 章 Agent Handoff：任务移交与协作协议</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 7 章 OpenAI Harmony 格式与多模态消息协议</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 8 章 Multi-Agent：从单体到群体协作</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 9 章 与仿真系统互动：闭环、采样与安全</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 10 章 Trace 构造、蒸馏与 Benchmark 评测体系</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 11 章 DeepResearch 智能体：多模态研究与长文档 PDF</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 12 章 Coding Agent：从仓库理解到可合并 PR</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 13 章 自动驾驶 VLA Agent：从感知到闭环决策</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 14 章 座舱多模对话机器人：可控、可靠、可解释</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 15 章 GeoGuessr / 地理定位 Agent：从一张图到一个世界坐标</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[第 16 章 机器人操作与具身 VLA Agent](https://www.google.com/search?q=chapter16.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="6-agent-handoff">第 6 章 Agent Handoff：任务移交与协作协议</h1>
<h3 id="1">1. 开篇段落</h3>
<p>在构建复杂的智能体系统时，<strong>"单体全能"（One Model Fits All）</strong> 的幻想往往是项目失败的根源。尽管 GPT-4o 或 Gemini 1.5 Pro 等模型拥有巨大的上下文窗口，但试图让一个 Agent 连续完成“读取 500 页技术文档 -&gt; 编写 Python 代码验证 -&gt; 撰写商业报告”的全流程，通常会导致以下问题：</p>
<ol>
<li><strong>注意力稀释（Attention Dilution）</strong>：随着上下文变长，模型对早期指令或中间约束的遵循能力显著下降（Lost-in-the-Middle 现象）。</li>
<li><strong>角色混淆（Role Confusion）</strong>：同一个 System Prompt 难以同时包含“严谨的审计员”和“富有创意的营销专家”两种立的人格约束。</li>
<li><strong>成本失控</strong>：在长对话后期，为了修改一个标点符号而重新输入 100k tokens 是极大的浪费。</li>
</ol>
<p><strong>Agent Handoff（智能体移交）</strong> 是解决这些问题的核心架构模式。它不只是简单的函数调用，而是<strong>责任、上下文与状态的正式转移</strong>。本章将深入探讨如何设计一套“防弹”的移交协议，确保任务在不同专家 Agent（或人类）之间流转时，信息不丢失、目标不偏移、死循环被阻断。</p>
<p><strong>本章学习目标：</strong></p>
<ol>
<li><strong>架构视角</strong>：掌握线性、星型、分层等多种移交拓扑及其适用场景。</li>
<li><strong>协议设计</strong>：构建标准化的 <strong>Handoff Packet（移交包）</strong>，实现“无状态重启”与“有损压缩”。</li>
<li><strong>多模态流转</strong>：解决图片、音频、长文档在 Agent 间传递时的引用与带宽问题。</li>
<li><strong>防御性工程</strong>：设计握手、拒绝与回退机制，防止“击鼓传花”式的死循环。</li>
</ol>
<hr />
<h3 id="2">2. 核心论述：移交的工程艺术</h3>
<h4 id="21">2.1 移交的本质：降低熵增</h4>
<p>智能体系统的运行过程是一个熵增过程（噪声积累）。Handoff 的本质是一次<strong>熵减操作</strong>。
通过 Handoff，我们将前序 Agent 产生的冗长、混乱的思维链（Chain of Thought）和试错过程，压缩为清晰的<strong>“结论”</strong>和<strong>“资产”</strong>，传递给下一个拥有全新、干净上下文窗口（Context Window）的 Agent。</p>
<h4 id="22-handoff-topologies">2.2 移交拓扑结构 (Handoff Topologies)</h4>
<p>不同的业务流需要不同的移交模式。不要被“多智能体”这个词迷惑，即使是两个 Agent，也存在复杂的拓扑。</p>
<p><strong>A. 线性接力 (The Relay / Pipeline)</strong>
最简单、最稳健的模式。适用于标准化作业流程（SOP）。</p>
<ul>
<li><strong>适用</strong>：文档处理流水线（OCR -&gt; 翻译 -&gt; 摘要 -&gt; 格式化）。</li>
<li><strong>特点</strong>：单向流动，无回环。</li>
</ul>
<div class="codehilite"><pre><span></span><code>[ Source ] -&gt; (Agent A: Ingest) -&gt; [Structured Data] -&gt; (Agent B: Analyze) -&gt; [Report] -&gt; (Agent C: Publish)
</code></pre></div>

<p><strong>B. 星型路由 (Hub-and-Spoke / Router)</strong>
通过一个中央大脑（Router）来分发任务。</p>
<ul>
<li><strong>适用</strong>：用户意图不明确的复杂对话助手（如客服总台）。</li>
<li><strong>特点</strong>：中央节点必须足够“聪明”且“克制”，只做分发，不做执行。</li>
<li><strong>难点</strong>：Router 容易成为瓶颈。如果 Router 判断错误，后续全是错的。</li>
</ul>
<div class="codehilite"><pre><span></span><code>                 +-----------+
                 |  Router   |
                 +-----+-----+
   (1) Intent?      /  |  \      (3) Aggregate
                   /   |   \
        +---------+ +--+--+ +---------+
        | Search  | | Code| | Draw    |
        +---------+ +-----+ +---------+
             (2) Execute &amp; Return
</code></pre></div>

<p><strong>C. 升级与回退 (Escalation &amp; Fallback)</strong>
这是生产环境中最关键的模式。</p>
<ul>
<li><strong>一级移交</strong>：快速模型（如 GPT-4o-mini）处理简单任务。</li>
<li><strong>二级移交</strong>：遇到低置信度或复杂逻辑，移交给强模型（如 GPT-4o/Claude 3.5）。</li>
<li><strong>三级移交</strong>：<strong>Human-in-the-Loop</strong>。当机器搞不时，生成一张工单（Ticket），移交给人类操作员。</li>
</ul>
<p><strong>D. 动态协作 (Dynamic Collaboration / Swarm)</strong>
Agent 之间可以任意互相呼叫（类似于微服务网格）。</p>
<ul>
<li><strong>风险</strong>：极易产生死循环（Agent A 叫 B，B 叫 A）。必须引入 TTL（生存时间）或最大跳数限制。</li>
</ul>
<h4 id="23-handoff-packet">2.3 核心协议：Handoff Packet (移交包)</h4>
<p>移交<strong>绝对不应该</strong>是把整个 Chat History 扔给下一个 Agent。这既昂贵又充满了上一轮的“思维垃圾”。
你需要定义一个标准化的 <strong>JSON Schema</strong> 作为移交包。</p>
<p>一个健壮的 Handoff Packet 必须包含以下四个象限：</p>
<p>| 字段类别 | 关键内容 | 说明 |</p>
<table>
<thead>
<tr>
<th>字段类别</th>
<th>关键内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. Meta (元数据)</strong></td>
<td><code>source_agent</code>, <code>target_agent</code>, <code>timestamp</code>, <code>handoff_id</code>, <code>priority</code></td>
<td>用于追踪、日志审计和防死循环（Traceability）。</td>
</tr>
<tr>
<td><strong>2. Mission (任务)</strong></td>
<td><code>objective</code>, <code>definition_of_done</code> (DOD), <code>constraints</code></td>
<td>下一个 Agent <strong>必须</strong>做什么？什么算做完？有什么禁？</td>
</tr>
<tr>
<td><strong>3. Context (上下文)</strong></td>
<td><code>summary_so_far</code>, <code>user_original_intent</code>, <code>key_facts</code></td>
<td>对前序工作的<strong>有损压缩</strong>。只保留结论，丢弃推理过程。</td>
</tr>
<tr>
<td><strong>4. Artifacts (资产)</strong></td>
<td><code>file_uris</code>, <code>image_ids</code>, <code>db_record_ids</code>, <code>extracted_data</code></td>
<td><strong>引用指针</strong>。不要传文件内容，传 S3 链接或数据库 ID。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>多模态特别说明 (Rule of Thumb)</strong>：</p>
<ul>
<li><strong>图片</strong>：传递 <code>image_id</code> 或 <code>url</code>。如果 Agent A 已经在图片坐标 (100, 200) 处发现异常，Packet 中应包含 <code>{"region_of_interest": [100, 200, 50, 50], "desc": "crack detected"}</code>，而不是让 Agent B 重新去“找茬”。</li>
<li><strong>文档</strong>：传递文档 ID + 页码引用（Page Ref）。例如 <code>{"ref": "doc_123", "pages": [5, 6], "snippet": "..."}</code>。</li>
</ul>
</blockquote>
<h4 id="24">2.4 上下文压缩策略：如何“断章取义”？</h4>
<p>移交时的最大痛点是信息丢失。如何保证 Agent B 能接得住？</p>
<ol>
<li><strong>摘要链 (Summary Chain)</strong>：Agent A 在移交前，必须执行一个内部思考步骤：“总结我目前已知的信息，并为下一个接手者写一份简报”。这份简报是 Packet 的核心。</li>
<li><strong>不可变事实 (Immutable Facts)</strong>：维护一个全局的 KV 存储或清单。例如用户的姓名、订单号、已确认的需求。这些信息不随 Handoff 压缩，而是作为附件始终跟随。</li>
<li><strong>回溯指针 (Back-links)</strong>：如果 Agent B 对简报有疑问，Packet 中应包含指向 Agent A 完整日志的链接（Trace ID），允许 B 在极少数情况下“查阅原档”（虽然我们尽量避免）。</li>
</ol>
<h4 id="25-rejection-handshake">2.5 拒绝与握手协议 (Rejection &amp; Handshake)</h4>
<p>Agent Handoff 不总是成功的。Agent B 可能认为任务描述不清，或者自己无法处理。</p>
<ul>
<li><strong>ACK/NACK 机制</strong>：</li>
<li>Agent A 发送 Packet。</li>
<li>Agent B 先进行 <strong>Sanity Check（健全性检查）</strong>：输入是否缺字段？图片是否无法下载？</li>
<li>如果检查失败，B 返回 <code>NACK</code> (Negative Acknowledgement) + <code>reason</code>，把球踢回给 A。</li>
<li>
<p>A 收到 <code>NACK</code> 后，触发<strong>自我修正 (Self-Correction)</strong> 或报错。</p>
</li>
<li>
<p><strong>能力边界声明</strong>：每个 Agent 的 System Prompt 中应明确定义：“如果你收到不属于你能力范围的任务，请立即发起 Handoff 退回或转交，不要尝试强行回答”。</p>
</li>
</ul>
<hr />
<h3 id="3">3. 本章小结</h3>
<ol>
<li><strong>分而治之</strong>：Handoff 是解决 Context 限制和能力专业化的唯一路径。</li>
<li><strong>协议至上</strong>：定义清晰的 Handoff Packet 结构（Meta, Mission, Context, Artifacts）比优化 Prompt 更重要。</li>
<li><strong>引用代替拷贝</strong>：在多模态系统中，始终传递资产的 URI 和 ID，而非 Base64 或原始文本。</li>
<li><strong>防卫性设计</strong>：必须设计死循环检测（TTL）、拒绝机制（NACK）和人工接管通道（Escalation）。</li>
<li><strong>有损压缩</strong>：移交必然丢失信息，关键在于保留“结论”和“事实”，丢弃“过程”和“噪音”。</li>
</ol>
<hr />
<h3 id="4">4. 练习题</h3>
<h4 id="50">基础题 (50%) —— 熟悉协议与流程</h4>
<details>
<summary><strong>Q1: 为什么在移交时，不建议直接把上轮的 Chat History 完整拼接到下一个 Agent 的 Prompt 中？请列举三个原因。</strong> (点击展开)</summary>
<ol>
<li><strong>成本与配额</strong>：历史记录可能非常长，导致 Token 消耗指数级增长，且容易超出上下文窗口限制。</li>
<li><strong>注意力干扰（噪音）</strong>：上一个 Agent 的试错过程、失败尝试和纠结的思维链，对下一个 Agent 来说是干扰信息，可能导致它重蹈覆辙或产生幻觉。</li>
<li><strong>角色污染</strong>：上一个 Agent 的 System Prompt 或对话风格可能会“泄漏”到下一个 Agent，导致角色扮演失败（例如严谨的审核员开始像推销员一样说话）。</li>
</ol>
<p><strong>提示</strong>：想象一下，你接手同事的工作时，是希望他给你一份 500 页的聊天记录，还是一份 1 页的交接文档？</p>
</details>
<details>
<summary><strong>Q2: 设计一个简单的 JSON Handoff Packet，用于将一个“PDF 总结任务”从“阅读者 Agent”移交给“翻译 Agent”。</strong> (点击展开)</summary>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;meta&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;from&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;reader_agent_v1&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;to&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;translator_agent_v1&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;trace_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;trace_88219&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;task&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;action&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;translate_summary&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;target_language&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Spanish&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;tone&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;professional&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;context&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;summary_content&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;The Q3 financial report shows a 20% increase in revenue...&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;key_terms&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;EBITDA&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;YoY&quot;</span><span class="p">]</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;artifacts&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;source_doc_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;s3://docs/q3_report.pdf&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;source_page_refs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>提示</strong>：包含元数据、具体要做什么、原始内容是什么、以及原始文件的引用。</p>
</details>
<details>
<summary><strong>Q3: 什么是“死循环移交”（Infinite Handoff Loop）？如何通过协议字段防止它？</strong> (点击展开)</summary>
<p><strong>现象</strong>：Agent A 觉得这事该 B 做，移交给 B；B 看了觉得缺信息，又移回给 A。两者反复踢皮球。</p>
<p><strong>防止手段</strong>：</p>
<ol>
<li><strong>TTL / Hop Count</strong>：在 Packet 的 <code>meta</code> 中增加 <code>hop_count</code> 字段，每次移交 +1。如果超过阈值（如 5），强制终止或转人工。</li>
<li><strong>Chain History</strong>：记录已经经手过的 Agent 列表 <code>["A", "B"]</code>。B 看到 A 已经在列表里，且任务状态未变，应触发报错而非回传。</li>
</ol>
<p><strong>提示</strong>：网络数据包中的 TTL 字段是做什么的？</p>
</details>
<hr />
<h4 id="50_1">挑战题 (50%) —— 系统设计与工程思维</h4>
<details>
<summary><strong>Q4: 场景：DeepResearch Agent 正在撰写报告，需要一张图表。它移交给 Code Agent 画图，但 Code Agent 报错说“数据列缺失”。请设计一个带有“自我修复”能力的移交流程。</strong> (点击展开)</summary>
<p>这是一个典型的 <strong>Request-Reply-Repair</strong> 模式：</p>
<ol>
<li><strong>Attempt 1</strong>: Research Agent -&gt; Handoff Packet (含数据) -&gt; Code Agent。</li>
<li><strong>Failure</strong>: Code Agent 运行 Python 失败，捕获 <code>KeyError: 'revenue'</code>。</li>
<li>
<p><strong>Return (NACK)</strong>: Code Agent 不只是报错停止，而是发起一个 <strong>Reverse Handoff</strong> 回给 Research Agent。
* Content: "Execution Failed."
* Reason: "Missing column 'revenue' in provided dataset."
* Suggestion: "Please check extraction or provide correct CSV."</p>
</li>
<li>
<p><strong>Repair</strong>: Research Agent 收到退回包，读取 Reason。它的 Policy 决定重新读取文档提取 'revenue' 列。</p>
</li>
<li><strong>Attempt 2</strong>: Research Agent 发送新的 Packet (含修复后的数据) -&gt; Code Agent。</li>
<li><strong>Success</strong>: Code Agent 绘图成功，返回 Image URI。</li>
</ol>
<p><strong>关键点</strong>：Code Agent 的报错必须结构化返回给 Research Agent，而不是抛给用户。</p>
</details>
<details>
<summary><strong>Q5: 在“人机移交”（Human Handoff）场景中，如何处理“人类操作员下班了”导致的长延迟问题？这对系统架构有什么影响？</strong> (点击展开)</summary>
<p><strong>核心挑战</strong>：<strong>状态持久化与唤醒（State Hydration）</strong>。</p>
<ol>
<li><strong>异步架构</strong>：系统不能让 Python 线程或 API 连接一直 <code>sleep()</code> 等待人类。</li>
<li><strong>序列化存储</strong>：当决定移交给人时，必须将当前 Handoff Packet 序列化存入数据库（PostgreSQL/Redis），标记状态为 <code>WAITING_FOR_HUMAN</code>，并释放计算资源。</li>
<li><strong>回调钩子 (Webhook)</strong>：当人类在 UI 上完成操作并点击“提交”时，前端触发 Webhook。</li>
<li><strong>状态恢复</strong>：系统根据 ID 从数据库拉取 Packet，将人类的输入注入到 <code>context</code> 中，然后<strong>重新实例化</strong>一个新的 Agent 继续运行。</li>
</ol>
<p><strong>结论</strong>：人机移交强制要求系统架构必须是<strong>无状态（Stateless）</strong>且<strong>事件驱动（Event-driven）</strong>的。</p>
</details>
<details>
<summary><strong>Q6 (开放题): 假设你有一个包含 5 个不同专家 Agent 的系统。请设计一个评分机制，让 Router 自动决定把任务派给谁，而不是写死规则。</strong> (点击展开)</summary>
<p><strong>思路：基于描述符的语义匹配（Semantic Routing）。</strong></p>
<ol>
<li>
<p><strong>注册机制</strong>：每个 Agent 在启动时，向 Router 注册自己的 <code>Manifest</code>（清单）。
* <code>Agent A (Coder)</code>: "擅长 Python, 数据处理, 绘图。输入需要 CSV。"
* <code>Agent B (Writer)</code>: "擅长 本润色, 创意写作, 总结。输入需要文本。"</p>
</li>
<li>
<p><strong>任务向量化</strong>：Router 接收到任务 "帮我分析这个 Excel 并画个图" 时，将其 Embedding 为向量。</p>
</li>
<li><strong>相似度匹配</strong>：计算 任务向量 与 Agent 描述向量 的相似度（Cosine Similarity）。</li>
<li><strong>动态选择</strong>：选择得分最高的 Agent。</li>
<li><strong>反馈闭环 (RLHF)</strong>：如果 Router 派给 A，但 A 失败了（返回 NACK），Router 应降低该类任务对 A 的权重，并尝试得分第二高的 Agent。</li>
</ol>
<p><strong>提示</strong>：这类似于 RAG 中的检索过程，只不过检索的是“工具人”而不是“文档”。</p>
</details>
<hr />
<h3 id="5-gotchas">5. 常见陷阱与错误 (Gotchas)</h3>
<h4 id="51-the-telephone-game">5.1 传声筒效应 (The Telephone Game)</h4>
<ul>
<li><strong>现象</strong>：Agent A 读了 PDF，总结给 B；B 读了总结，精简给 C。到了 C，"利润增长 50%" 变成了 "利润有增长"，关键细节丢失。</li>
<li><strong>调试技巧</strong>：</li>
<li><strong>证据穿透</strong>：允许 C 直接访问 A 提取的原始数据片段（Raw Snippets），而不仅是 B 的转述。</li>
<li><strong>检查点测试</strong>：人工检查中间环节的 Packet 内容，确认信息熵减是否过度。</li>
</ul>
<h4 id="52-schema-promise-break">5.2 格式承诺崩溃 (Schema Promise Break)</h4>
<ul>
<li><strong>现象</strong>：Agent A 的 Prompt 里写着“请输出 JSON”，但因为模型抽风输出了 Markdown 代码块包裹的 JSON。Agent B 的解析器直接崩溃。</li>
<li><strong>调试技巧</strong>：</li>
<li><strong>中间件清洗</strong>：在 Handoff 发生前，增加一个非 AI 的代码层（Parser），负责把 Markdown 清洗掉，提取纯 JSON。如果提取失败，直接在代码层打回给 A 重试，<strong>严禁</strong>把脏数据传给 B。</li>
</ul>
<h4 id="53-hallucinated-references">5.3 幻觉引用 (Hallucinated References)</h4>
<ul>
<li><strong>现象</strong>：Agent A 并没有生成图片，但为了满足输出要求，捏造了一个 <code>image_id: "img_1234"</code>。Agent B 拿着这个 ID 去数据库查，发现为空，程序崩溃。</li>
<li><strong>调试技巧</strong>：</li>
<li><strong>存在性校验</strong>：Artifacts 字段必须经过系统校验。如果 ID 在数据库不存在，系统层拦截 Packet，标记为“非法移交”。</li>
</ul>
<h4 id="54-phantom-privileges">5.4 幽灵权限 (Phantom Privileges)</h4>
<ul>
<li><strong>现象</strong>：用户把“删除文件”的权限授给了 Agent A（管家），但 A 移交给了 Agent B（外部插件）。B 继承了 A 的权限删除了文件。这违反了安全原则。</li>
<li><strong>调试技巧</strong>：</li>
<li><strong>权限降级</strong>：Handoff 时，Packet 中应包含 <code>scope</code> 字段。Agent B 启动时，只能获得 Packet 中明确授权的最小权限集，而不是继承 A 的所有权限。</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter5.html" class="nav-link prev">← 第 5 章 记忆与知识：RAG、多模态检索与状态管理</a><a href="chapter7.html" class="nav-link next">第 7 章 OpenAI Harmony 格式与多模态消息协议 →</a></nav>
        </main>
    </div>
</body>
</html>